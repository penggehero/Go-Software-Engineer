# 数组、链表、栈、队列

## 1. 数组原理讲解、实战应用

### 数组（array）

```
C++: int a[100];
Java: int[]a= new int[100];
Python: a=[]
```

- 数组的基本特点：支持随机访问
- 数组的关键：索引与寻址
- 数组在内存是一段连续的存储空间

### 时间复杂度

- Lookup                         O(1)
- insert                            O(n)
- Delete                           O(n)
- Apend(push back)        O(1)
- Prepend(push front)    O(n)

### 实战

过滤器思想，符号条件就要，适应于保持相对顺序的。

```go
	n := 0
	for i := 0; i < len(arr); i++ {
        if 判断条件 {
            arr[n] = xxx
        }
	}
```

[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```go
// 过滤器思想 (适应于保持相对顺序的)
func removeDuplicates(nums []int) (n int) {
	for i := 0; i < len(nums); i++ {
		if nums[i] > nums[n] {
			n++
			nums[n] = nums[i]
		}
	}
	return n + 1
}
```

[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/)

```go
// 过滤器思想 (适应于保持相对顺序的)
func moveZeroes(nums []int) {
	n := 0
	for i := 0; i < len(nums); i++ {
		if nums[i] != 0 {
			nums[n] = nums[i]
			n++
		}
	}
	for i := n; i < len(nums); i++ {
		nums[i] = 0
	}
}
```

[88. 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/)

```go
// 过滤器思想 （只不过需要倒着处理，正着不好处理）
func merge(nums1 []int, m int, nums2 []int, n int) {
	i, j := m-1, n-1
	for k := m + n - 1; k >= 0; k-- {
		if j < 0 || (i >= 0 && nums1[i] >= nums2[j]) {
			nums1[k] = nums1[i]
			i--
		} else {
			nums1[k] = nums2[j]
			j--
		}
	}
}

// 双指针思想
func merge(nums1 []int, m int, nums2 []int, n int) {
	arr := make([]int, 0)
	i, j := 0, 0
	for {
		if i == m {
			arr = append(arr, nums2[j:]...)
			break
		}
		if j == n {
			arr = append(arr, nums1[i:]...)
			break
		}
		if nums1[i] > nums2[j] {
			arr = append(arr, nums2[j])
			j++
		} else {
			arr = append(arr, nums1[i])
			i++
		}
	}
	copy(nums1, arr)
}
```

